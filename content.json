{"meta":{"title":"lilusheng的技术博客","subtitle":"胆小认生，但是好相处","description":"擅长各项前端技能，深入研究移动端开发与前端性能。","author":"lilusheng","url":"https://maggicmuling.github.io","root":"/"},"pages":[],"posts":[{"title":"js中的闭包","slug":"js中的闭包","date":"2022-03-24T13:06:22.000Z","updated":"2022-03-24T13:26:28.306Z","comments":true,"path":"2022/03/24/js中的闭包/","link":"","permalink":"https://maggicmuling.github.io/2022/03/24/js%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85/","excerpt":"","text":"了解闭包前先来了解一下上级作用域和堆栈内存释放问题。 上级作用域的概念函数的上级作用域在哪里创建创建的，上级作用域就是谁 12345678910111213var a = 10function foo()&#123; console.log(a)&#125;function sum() &#123; var a = 20 foo()&#125;sum()/* 输出 10/ 函数 foo() 是在全局下创建的，所以 a 的上级作用域就是 window，输出就是 10 JS 堆栈内存释放堆内存：存储引用类型值，对象类型就是键值对，函数就是代码字符串。 堆内存释放：将引用类型的空间地址变量赋值成 null，或没有变量占用堆内存了浏览器就会释放掉这个地址 栈内存：提供代码执行的环境和存储基本类型值。 栈内存释放：一般当函数执行完后函数的私有作用域就会被释放掉。 但栈内存的释放也有特殊情况：① 函数执行完，但是函数的私有作用域内有内容被栈外的变量还在使用的，栈内存就不能释放里面的基本值也就不会被释放。② 全局下的栈内存只有页面被关闭的时候才会被释放 闭包是什么在 JS 忍者秘籍(P90)中对闭包的定义：闭包允许函数访问并操作函数外部的变量。红宝书上对于闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数。MDN 对闭包的定义为：闭包是指那些能够访问自由变量的函数。这里的自由变量是外部函数作用域中的变量。(闭包是指有权访问另一个函数作用域中变量的函数) 形成闭包的原因内部的函数存在外部作用域的引用就会导致闭包。 12345678910var a = 0function foo()&#123; var b =14 function fo()&#123; console.log(a, b) &#125; fo()&#125;foo()// 这里的子函数 fo 内存就存在外部作用域的引用 a, b，所以这就会产生闭包 闭包变量存储的位置闭包中的变量存储的位置是堆内存。 — 如闭包中的变量存储在栈内存中，那么栈的回收 会把处于栈顶的变量自动回收。所以闭包中的变量如果处于栈中那么变量被销毁后，闭包中的变量就没有了。所以闭包引用的变量是出于堆内存中的。 闭包的作用保护函数的私有变量不受外部的干扰。形成不销毁的栈内存。保存，把一些函数内的值保存下来。闭包可以实现方法和属性的私有化 闭包经典使用场景1 、return 回一个函数 12345678910111213var n = 10function fn()&#123; var n =20 function f() &#123; n++; console.log(n) &#125; return f&#125;var x = fn()x() // 21// 这里的 return f, f()就是一个闭包，存在上级作用域的引用。 2 、 节流防抖 1234567891011121314151617181920212223// 节流function throttle(fn, timeout) &#123; let timer = null return function (...arg) &#123; if(timer) return timer = setTimeout(() =&gt; &#123; fn.apply(this, arg) timer = null &#125;, timeout) &#125;&#125;// 防抖function debounce(fn, timeout)&#123; let timer = null return function(...arg)&#123; clearTimeout(timer) timer = setTimeout(() =&gt; &#123; fn.apply(this, arg) &#125;, timeout) &#125;&#125;","categories":[],"tags":[]},{"title":"rem适配原理","slug":"rem适配原理","date":"2022-03-24T12:52:04.000Z","updated":"2022-03-24T13:04:41.668Z","comments":true,"path":"2022/03/24/rem适配原理/","link":"","permalink":"https://maggicmuling.github.io/2022/03/24/rem%E9%80%82%E9%85%8D%E5%8E%9F%E7%90%86/","excerpt":"","text":"rem 适配原理什么是remrem是根元素字体的单位，比如 html{font-size:16px;} ，1rem相当于16px。不仅仅可以给字体用，其他px单位的都可以用，比如设padding:2rem ，相当于32px。 rem有什么用放弃px单位，使用rem作为单位，这样在不同尺寸的设备上，通过修改根节点的font-size大小，实现等比例缩放 123456789101112131415161718192021222324;(function (win, doc) &#123; var docEl = doc.documentElement, resizeEvt = &#x27;orientationchange&#x27; in window ? &#x27;orientationchange&#x27; : &#x27;resize&#x27; function refresh() &#123; var w = docEl.clientWidth, dpr = win.devicePixelRatio || 1 if (w &lt;= 750) &#123; docEl.style.fontSize = 100 * (w / 750) + &#x27;px&#x27; function setBodyFontSize() &#123; if (doc.body) &#123; doc.body.style.fontSize = &#x27;16px&#x27; &#125; else &#123; doc.addEventListener(&#x27;DOMContentLoaded&#x27;, refresh) console.log(11111) &#125; &#125; setBodyFontSize() &#125; &#125; refresh() if (!doc.addEventListener) return win.addEventListener(resizeEvt, refresh, false) &#125;)(window, document) 为什么不设置 font-size:62.5% ？因为谷歌有些版本不支持10px大小的字体 为什么不使用 em ？同百分比一样，相对于父元素计算不方便 为什么不使用 viewport 等比缩放？viewport的做法： 1&lt;meta name=&quot; viewport &quot; content=&quot; width=320, maximum-scale=1.3, user-scalable=no &quot;&gt; 这种做法是将屏幕等比缩放，缩放过大时会失真 使用rem web就是响应式的了吗？不是，rem只是等比缩放，只解决了响应式布局的准则 的部分问题 ，还需要配合媒体查询","categories":[],"tags":[]},{"title":"react脚手架配置代理总结","slug":"react脚手架配置代理","date":"2022-03-22T15:37:30.000Z","updated":"2022-03-22T15:46:41.700Z","comments":true,"path":"2022/03/22/react脚手架配置代理/","link":"","permalink":"https://maggicmuling.github.io/2022/03/22/react%E8%84%9A%E6%89%8B%E6%9E%B6%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/","excerpt":"","text":"react脚手架配置代理总结方法一 在package.json中追加如下配置 1&quot;proxy&quot;:&quot;http://localhost:5000&quot; 说明： 优点：配置简单，前端请求资源时可以不加任何前缀。 缺点：不能配置多个代理。 工作方式：上述方式配置代理，当请求了3000不存在的资源时，那么该请求会转发给5000 （优先匹配前端资源） 方法二 第一步：创建代理配置文件 1在src下创建配置文件：src/setupProxy.js 编写setupProxy.js配置具体代理规则： 123456789101112131415161718192021const proxy = require(&#x27;http-proxy-middleware&#x27;)module.exports = function(app) &#123; app.use( proxy(&#x27;/api1&#x27;, &#123; //api1是需要转发的请求(所有带有/api1前缀的请求都会转发给5000) target: &#x27;http://localhost:5000&#x27;, //配置转发目标地址(能返回数据的服务器地址) changeOrigin: true, //控制服务器接收到的请求头中host字段的值 /* changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000 changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:3000 changeOrigin默认值为false，但我们一般将changeOrigin值设为true */ pathRewrite: &#123;&#x27;^/api1&#x27;: &#x27;&#x27;&#125; //去除请求前缀，保证交给后台服务器的是正常请求地址(必须配置) &#125;), proxy(&#x27;/api2&#x27;, &#123; target: &#x27;http://localhost:5001&#x27;, changeOrigin: true, pathRewrite: &#123;&#x27;^/api2&#x27;: &#x27;&#x27;&#125; &#125;) )&#125; 说明： 优点：可以配置多个代理，可以灵活的控制请求是否走代理。 缺点：配置繁琐，前端请求资源时必须加前缀。 ￼路由组件与一般组件 1.写法不同： 一般组件： 路由组件：2.存放文件夹位置不同： 一般组件：components 路由组件：pages3.接收到的props不同（根本区别）： 一般组件：组件标签写什么值就传什么值 路由组件：一定会接收到路由的信息（history、location、match等），也可以传自定义的属性值 Link现在，我们应用需要在各个页面间切换，如果使用锚点元素实现，在每次点击时，页面被重新加载，React Router提供了组件用来避免这种状况发生。当 你点击时，url会更新，组件会被重新渲染，但是页面不会重新加载 是的一个特定版本，会在匹配上当前的url的时候给已经渲染的元素添加参数，组件的属性有 activeClassName(string)：设置选中样式，默认值为activeactiveStyle(object)：当元素被选中时，为此元素添加样式exact(bool)：为true时，只有当导致和完全匹配class和style才会应用strict(bool)：为true时，在确定为位置是否与当前URL匹配时，将考虑位置pathname后的斜线isActive(func)判断链接是否激活的额外逻辑的功能 ￼￼￼￼￼withRouter 加工一般组件，让一般组件具有路由组件所特有的apiwithRouter的返回值是一个新的组件￼￼添加redux中数组的数据时，原先使用push和unpush 数据添加进去但是页面未刷新，原因是redux底层对返回值做了一个浅比较，使用push数组地址未发生改变，所以不进行页面更新，同时破坏了reduce纯函数的原则 nanoid 随机生成id不重复可做key值 ￼1.第一种配置代理方式￼Proxy 设置代理￼￼3000是项目的地址，通过package.json 配置proxy代理到5000，然后发送请求时将服务区5000地址更改为3000可自动转为5000发送请求（只能设置一个代理地址） 2.设置setupProxy来设置代理￼￼可配置多个代理地址","categories":[],"tags":[]},{"title":"vue组间通信","slug":"My-first","date":"2018-03-22T05:58:42.000Z","updated":"2022-03-23T05:19:55.570Z","comments":true,"path":"2018/03/22/My-first/","link":"","permalink":"https://maggicmuling.github.io/2018/03/22/My-first/","excerpt":"","text":"","categories":[],"tags":[]}],"categories":[],"tags":[]}